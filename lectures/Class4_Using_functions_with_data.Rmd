---
title: 'Using Functions with Data'
author: "Naomi Tague"
date: "January, 2025"
output:
  slidy_presentation:
   highlight: pygments
  html_document: default
  pdf_document: default
  ioslides_presentation:
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo =TRUE)

library(tidyverse)
library(purrr)
library(ggpubr)
```

# Questions

* sampling_example.Rmd
* error_checking.Rmd

# Steps for running your function over multiple inputs

1. design a data structure to store results: sometimes this is automatic but not always
2. generate the input data
3. apply to the function



# Consider our function that estimates the power required to keep a car moving at a given speed
 Code

```{r powerexample}

#' Power Required by Speed
#'
#' This function determines the power required to keep a vehicle moving at 
#' a given speed
#' @param cdrag coefficient due to drag default=0.3 
#' @param crolling coefficient due to rolling/friction default=0.015
#' @param v vehicle speed (m/2)
#' @param m vehicle mass (kg)
#' @param A area of front of vehicle (m2)
#' @param g acceleration due to gravity (m/s) default=9.8
#' @param pair (kg/m3) default =1.2
#' @return power (W)

autopower = function(V, m, A, cdrag=0.3, crolling=0.015,pair=1.2,g=9.8) {
  P = crolling*m*g*V + 1/2*A*pair*cdrag*V**3
  return(P)
}

```

I've also stored the autopower.R function as a file  using the recommended naming convention

**autopower.R**


# Generating data for the function and iterating over that data

Two parts

* Generate a data structure to store your results

* Repeat application of your function over the data


Example use: Imagine we want to see how much power is generated given a scenario where we know the mean and standard deviation of vehicle speeds


```{r sampling}

source("../R/autopower.R")

# generate sample speeds from a distribution
nsample = 100
speeds = rnorm(mean=25, sd=4, n=nsample)

# Step 1  create data frame to store results 
# how many simulations, what do you want to keep

#create a dataframe that has rows for each model run
# columns for height, flowrate and power estimate
results = data.frame(speed=speeds, power=NA)

head(results)

# if you only have one input and everything else is the same, R is smart enough
# to create a set of outputs
results$power = autopower(V=speeds, A=25, m=20000)

# ALWAYS look at your results to make sure it make sense
ggplot(results, aes(speed, power/1000))+geom_point()+labs(x="speed in m/s", y="power in kW")
ggplot(results, aes(x="POWER", y=power/1000))+geom_boxplot()+labs(y="power in kW", x="")

```

# Add error checking to your autopower function

* discuss what you did

# More formal error checking

R also has specified totols for returning error messages

You can also use *stop()* or *warning()* inside your function to 
alter the user

*stop()* stops the remainder of the functions from executing
*warning()* continues but lets the user know


# Another Example: Function to computed crop yield

Lets imagine that annual yield of a crop can be estimated follows:


$$ yield =  1.8*fertilizer^2 - 0.5*fertilizer  + 0.1*TP $$


and *TP* is mean precipitation in cm; *yield* is kg/year; *fertilizer* is kg/year

<span style="color:green">Practice</span>

Step 1: Code as a function 

Step 2: Generate a random sample of fertilizer application, 10 values
with mean of *5* and standard deviation of *0.5*
(user *rnorm* function in R to do this)

Step 3: Use the function :)

# What I did

```{r eval=TRUE, echo=TRUE, error=TRUE}

library(tidyverse)
# Write the function (save in an R file)
compute_yield = function(fert, TP) {
  
  # error checking
  fert = ifelse(fert >= 0, fert, return("fertilizer is negative"))
  TP  = ifelse(TP >= 0, TP, return("Precipitation(TP) is negative") )
  
  # we know that annual precipitation greater than 1000 cm is pretty unlikely so if we get that something is probably wrong so we warn the user (but we let the function continue just in case) 
  TP = ifelse(TP > 10000,  warning("Unrealistically high precipitation (TP)"),TP)
  
  # compute yield
  yield = 1.8*fert^2-0.5* fert + 0.1*TP
  return(yield)
}

# Generate inputs
fert = rnorm(n=10, mean=5, sd=0.5)
TP = 20
crop = data.frame(fert=fert)
crop$yield = NA

# apply function and save results
crop$yield = compute_yield(fert, TP)
ggplot(crop, aes(fert,yield) )+geom_point(size=2, col="green")+labs(y="Crop yield kg/yr",x="Fertilizer kg/yr")

# find the total yield
sum(compute_yield(fert, TP))

# See how error checking works
compute_yield(fert, -20)
compute_yield(fert, 2000000)
```

# A brief intro to Git 

Reproducbility and Collaboration are central parts of a good programming practice

For decades programmers have been using something called *git* to keep help collaborate on code, keep track of changes etc. 

*Git* a lot like using a google doc - but for code and data

Next week we will focus on *Git*

To use this tool requires some set up

# For next class (2 itemse)

1.  Please read and complete each of the steps in
**git_setup.RMD**


2. Complete Assignment 2 (Due Feb 24)

Think of a function that might be useful for environmental science and management data analysis. Keep it simple.

1. Code your function in R and store as a single .R file. Make sure you adequately comment and include some error checking.  

2. In Rmarkdown, generate some sample data and use this data to illustrate how your function might work. Then use this data to show what your function can do. You can be creative here - the illustration might be a graph or it could be a meaningful result (sum of yields). Just make sure you add enough text that we can understand what you did

3. Submit the .R file and the Rmarkdown file on Canvas

**Grading Rubric**

1. Correct coding of a function in R (10 pts)
2. Inclusion of error checking (5 pts)
3. Good programming style (comments, variables names) (5 pts)
4. Generation of sample data (5 pts)
5. Demonstration of function use (5 pts)



